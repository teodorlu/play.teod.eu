:PROPERTIES:
:ID: 51ffdc72-ed70-4703-a773-347344e5dd6e
:END:
#+TITLE: Hva er funksjonell programmering?

[[file:..][..]]

Funksjonell programmering er en /disiplin/ for å programmere som gjør det enklere å forstå koden din, og enklere å endre koden du allerede har skrevet.

I funksjonell programmering som beskrevet av Eric Normand[fn:grokking-simplicity] skiller vi mellom:

1. Data
2. Beregninger
3. Handlinger.

Data kan for eksempel være et JSON-objekt.
Beregninger er funksjoner fra data til data.
Handlinger har en /effekt/, for eksempel at data blir lagret i databasen, eller en /koeffekt/, for eksempel at vi henter ut dagens dato (forskjellig hver dag), eller antall brukere i systemet vårt.

Hvordan har funksjonell programmering påvirket dagens kultur for utvikling av webapplikasjoner?
La oss ta et tilbakeblikk.

Da Brendon Eich skulle lage et programmeringsspråk som skulle kjøre rett i nettleseren, ville han først lage en Scheme-dialekt[fn:js-scheme].
Scheme er et funksjonelt programmeringsspråk, Eich ville lage en variant som var lett å bruke til å lage interaktive nettsider.
Sjefene hans sa at det fikk han ikke lov til!
Sjefene hadde hørt om /Java/, og ville at programmeringsspråket Eich designet skulle likne på Java.
Så det var lett Java-utviklere å programmere interaktivitet i nettlesere.
Han fikk ti dager, og så ble JavaScript født.

Vi fikk så en objektorientert modell for hypertekst-dokumenter, som så fint fikk navnet /Document Object Model/[fn:dom].
Denne viste det seg at var vanskelig å jobbe med, så John Resig skrev jQuery[fn:jquery] for å kunne jobbe med hypertekst-dokumenter uten å lage så mange objekter.

Dette var fremdeles tungvindt.
Programmereren måtte selv sørge for å holde tilstand i synk med hva som ble vist på skjermen.
I tillegg ble sider skrevet med jQuery ofte trege etter hvert: jQuery oppdaterer /hele/ HTML-dokumentet hver gang brukeren endrer på noe.

Dette hadde Conal Elliot og Paul Hudak et svar på: /Funksjonell-reaktiv programmering/ (FRP)[fn:frp].
Elliot og Hudak designer et /språk/ (eller en /protokoll/ hvis du vil) for å la effekter reagerer på andre effekter.

I 2012 lagde Evan Czaplicki programmeringsspråket /Elm/ for å bruke FRP til å lage spill[fn:elm], og i 2013 lagde Jordan Walke React for å lage interaktive webapper[fn:react].
Det oppfordres først til å lage React-apper i objektorientert stil (React Class Components), før dette frarådes, og reaktive funksjoner (React Hooks) får førstesideplassen.

Jordan Walker lager i 2016 ReasonML[fn:reasonml], et språk som er funksjonelt /først/, i kontrast til Javascript, som har tungt fokus på klasser, objekter og syntaks som likner på Javascript.
ReasonML er basert på ML[fn:ml], og andre ML-baserte språk (Standard ML, OCaml, Haskell og F#).

Hvis vi skal behandle programmering som en seriøs disiplin, må vi forstå hvordan vi kom hit vi er i dag.

Jeg foretrekker å bruke programmeringsspråket Clojure[fn:clojure].
Clojure har knallgod støtte for funksjonell programmering og knallgode utviklerverktøy[fn:calva][fn:clerk].
Clojure er også lett å lære.
Clojure har et lite standardbibliotek med et smakfult utvalg funksjoner som funker bra sammen.
Syntaksen til språket er /ikke/ satt av en mellomleder som vil overbevise Java-utviklere, som lar oss unngå enda flere feil.

Men du trenger ikke skrive Clojure for å skrive funksjonell kode.
Skill mellom beregninger og handlinger i koden din.
Funksjoner returnerer enten et svar, eller kjører en sideeffekt.
Lag nyhetsbrevet du ønsker å sende ut /før/ du sender det ut.
Da er det rett fram å teste, og du slipper mocking.
Hvis du bruker et funksjonelt tankesett på systemnivå, ramler Event Sourcing[fn:event-sourcing] og Command Query Response Segregation[fn:cqrs] ut.
Plutselig cacher du på content id-er[fn:content-id] i stedet for referanser til muterbare objekter, og caching blir trivielt (i stedet for å være et "veldig vanskelig problem").

Min erfaring er at systemer som ikke skiller mellom muterende kode (handlinger) og ikke-muterende kode (beregninger) ender opp i en suppe av mutasjon der man ikke klarer å komme videre.
Funksjonell programmering gir en vei ut[fn:out-of-the-tar-pit].

Men da må vi sette oss ned og /legge ned en innsats for å lære/.
[[id:a172782b-bceb-4b44-afdf-7a2348d02970][Rich Hickey]] skiller i [[id:3eb092bf-b847-4686-b250-fca303022782][Simple Made Easy]] mellom ting som er /lett/ og ting som er /enkelt/.

- /lette ting/ er nær det vi kan akkurat nå.
  Det krever liten innsats.
- /enkle ting/ har få komponenter som ikke er sammenvevd.
  Enkle ting /kan deles opp/.

Hvis vi utelukkende skal gjøre lette ting, kommer vi ingen vei.
Vi lærer heller ingenting.
Vi lager derimot aktive hindre mot å lære noe som helst.
Å lære er tungt arbeid.
Det gjør vondt å koble om hjernen vår til å kunne tenke på en annen måte.
Hvis det er "lett", har vi ikke lært noe fundamentalt nytt.

Dagens store språkmodeller (large language models, LLM-er) som GPT-4 tydeliggjør dette skillet.
GPT-4 har lest enorme mengder tekst, og klarer å koble sammen kjente ting.
GPT-4 klare ikke å finne opp nye ting.
Hvis vi som utviklere fortsetter å vektlegge lette ting over enkle ting, kommer vil til å bli automatisert bort.

/Så hva bør jeg *gjøre*, da, Teodor, du får hodet mitt til å gjøre vondt!/

Hvis du har /én time/, hør på [[id:81dfcf30-e59d-4293-9000-5b29c97f90b8][Eric Normand]] hvordan han definerer funksjonell programmering:

<iframe style="border-radius:12px" src="https://open.spotify.com/embed/episode/4hSE898e7eV3ySlB8PabRY?utm_source=generator" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>

Hvis du har /10 timer/, les [[id:2dc52e4f-0604-4d33-a50c-1e8534266a47][Grokking Simplicity]].

Hvis du har /100 timer/, plukk deg et språk med førsteklasses støtte for funksjonell programmering (feks Elm, Elixir eller Clojure).
Sett av fire timer til å /komme i gang/ så du finner ut hvor du står fast.
Så løfter du de problemene opp til noen som kan språket du prøver å lære deg.

Funksjonell programmering er en disiplin som kommer til å gjøre deg til en permanent bedre utvikler.
Det er en ferdighet som varer og gir avkastning, uansett om du jobber i et språk med førsteklasses støtte for funksjonell programmering eller ikke.

[fn:grokking-simplicity] https://grokkingsimplicity.com/
[fn:js-scheme] https://en.wikipedia.org/wiki/Brendan_Eich#Netscape
[fn:dom] https://en.wikipedia.org/wiki/Document_Object_Model
[fn:jquery] https://en.wikipedia.org/wiki/JQuery
[fn:frp] http://conal.net/papers/icfp97/
[fn:elm] https://en.wikipedia.org/wiki/Elm_(programming_language)
[fn:reasonml] https://en.wikipedia.org/wiki/Reason_(programming_language)
[fn:ml] https://en.wikipedia.org/wiki/ML_(programming_language)
[fn:clojure] https://clojure.org/
[fn:clojure-easiest] https://clojureverse.org/t/clojure-has-a-dirty-little-secret/9160
[fn:calva] https://calva.io/
[fn:clerk] https://clerk.vision/
[fn:event-sourcing] https://martinfowler.com/eaaDev/EventSourcing.html
[fn:cqrs] https://martinfowler.com/bliki/CQRS.html
[fn:content-id] https://en.wikipedia.org/wiki/Content-addressable_storage
[fn:out-of-the-tar-pit] https://curtclifton.net/papers/MoseleyMarks06a.pdf
