#+title: Feedback loops, interface design and how stuff works

[[./..][..]]

State --- draft, but feedback would be good.
Consider skipping.

As software developers, we make decisions all day. How do I approach this
problem? How do I start carving off its unknown pieces? How can I know where to
direct my attention?

I've found that most of my effort as a software developer can be reduced to:

1. Designing, creating and using feedback loops
2. Designing interfaces
3. Discovering how stuff works.

Alternative title: /Multiscale design/.

Curious? Read on.

* In software development, design modules
| Author   | Software developer today |
| Consumer | Software developer later |
** Software feedback --- is it working now?
You're going to do the work.
But what do your increments look like?
How do you know that an increment works?
Letting you know whether / how your increments work is the job of your feedback loop.
You're going to be checking your feedback loop frequently as you work.
I prefer /very often/. Every ten seconds of more often.
Probably bound to some on-save action.
** Software interface design --- the thing you're making, how is it used?
The thing you're making.
How is it going to be used?
What do you provide?
A module with a public interface?
A REST endpoint?
Will your thing be /nice/ to use?

When you're working on interface design, it's your job to ensure that the things you're making are nice to use.
** Software implementation --- now, let's make it work.
With a good feedback loop and solid interface design, implementation is often the easy part.
A good feedback loop lets you know whether / how your thing works at every point in time.
And good interface design will split your problem into reasonable parts.
If implementation is hard, consider splitting your problem.
Splitting your problem /is/ introducing an interface.
So do a bit of interface design, then come back.
And ensure that your interface is easy to test --- this means you'll get value out of your feedback loop!
* In product, design user interfaces
| Author   | Product designer |
| Consumer | End-user         |
** Product feedback --- how do we see how well the product solves problems in context?
How long is the cycle time from changing product behavior to seeing how the new behavior performs?
How /wide/ is the product feedback that we're getting?
High-resolution feedback is being inside the user's head while they solve a complete product "job to be done".
Low-resolution feedback is asking the users what they think once in a while.
** Product interface --- what is the product as experienced by the user?
Does the user understand how to use the product?
How long does it take a new user to get up to speed?
How effectively can a user solve common tasks?
Where is the friction?
Are jobs to be done easier to get done with your product than with options?
What are the best jobs to be done?
** Implementation --- finally, what product increment do we build next?
Challenge: many features.

- To many features are hard to navigate.
  We want the minimal number of features that can solve a workflow.
- Features intersect.
  We want features to intersect /orthogonally/.

How do we perpetually add value without ending up in "buttons everywhere hell"?

Challenge: uncertainty.

- We don't really know how well a product works before we see it in action
- What parts of our product are cheap/expensive to change?
  - easy changes --- ergonomic affordances --- not structural
  - hard changes --- primary structure --- don't destroy existing content

How do we know what to make when we don't /really/ know before we're there --- and we might not have a return ticket?
* In innovation, design workflows
| Author   | Innovator |
| Consumer | Industry  |

Finally, the top level.
Let's recap.

Level 1 - software view.
The interface is the /module interface/.
Feedback is how easy it is to work with modules.

Level 2 - product view.
The interface is the /product texture/.
Feedback is how smooth it is to execute a workflow.

Makes sense?
Now, let's introduce the birds-eye view.

Level 3 - industry view.
The interface is current market best practices.
Feedback is how effectively the workflows can compete with other workflows.
Are you enabling better workflows?

* Retrospective on this article
Right now, I've split the article into sections about feedback loop, interface design and implementation.
That's clear.
However, the lines get kinda ... blurred sometimes.
Take the trailing part of the section about implementation in software development:

#+begin_quote
With a good feedback loop and solid interface design, implementation is often the easy part.
A good feedback loop lets you know whether / how your thing works at every point in time.
And good interface design will split your problem into reasonable parts.
If implementation is hard, consider splitting your problem.
Splitting your problem /is/ introducing an interface.
So do a bit of interface design, then come back.
And ensure that your interface is easy to test --- this means you'll get value out of your feedback loop!
#+end_quote

Would it be better to separate between definitions (what feedback/interface/implementation means in a context) and case-based discussion?
ðŸ¤”
